import re
import time
import math
import random
from datetime import datetime
from typing import List, Dict, Set, Tuple

import pandas as pd
from bs4 import BeautifulSoup

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.service import Service


# 3 trang bảng giá theo sàn
EXCHANGE_URL = {
    "HOSE":  "https://banggia.vietstock.vn/bang-gia/hose",
    "HNX":   "https://banggia.vietstock.vn/bang-gia/hnx",
    "UPCOM": "https://banggia.vietstock.vn/bang-gia/upcom",
}

# Lấy mã chuẩn (tránh BAFBAF)
CODE_RE = re.compile(r"\b[A-Z0-9]{1,6}\b")


def make_driver(headless: bool = True) -> webdriver.Chrome:
    opt = Options()
    if headless:
        opt.add_argument("--headless=new")
    opt.add_argument("--window-size=1400,900")
    opt.add_argument("--disable-gpu")
    opt.add_argument("--no-sandbox")
    opt.add_argument("--disable-dev-shm-usage")
    opt.add_argument("--lang=vi-VN")
    opt.add_argument(
        "user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
        "AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
    )

    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service, options=opt)
    driver.set_page_load_timeout(60)
    return driver


def _parse_symbols_from_html(html: str) -> List[str]:
    """Parse list symbol từ cột đầu tiên của bảng (Mã CK)."""
    soup = BeautifulSoup(html, "html.parser")
    out = []
    for tr in soup.select("table tbody tr"):
        tds = tr.find_all("td")
        if not tds:
            continue
        raw = tds[0].get_text(" ", strip=True)
        m = CODE_RE.search(raw)
        if not m:
            continue
        out.append(m.group(0).upper())
    return out


def _try_click_next(driver: webdriver.Chrome) -> bool:
    """
    Thử click nút Next (DataTables). True nếu click được, False nếu không có/disabled.
    """
    selectors = [
        "a.next",
        ".dataTables_paginate a.next",
        "li.paginate_button.next a",
        "a#banggia_next",
    ]

    for sel in selectors:
        els = driver.find_elements(By.CSS_SELECTOR, sel)
        if not els:
            continue
        a = els[0]

        # disabled thường nằm ở class của a hoặc parent li
        a_cls = a.get_attribute("class") or ""
        parent_cls = ""
        try:
            parent_cls = a.find_element(By.XPATH, "..").get_attribute("class") or ""
        except Exception:
            pass

        if "disabled" in (a_cls + " " + parent_cls):
            return False

        try:
            driver.execute_script("arguments[0].click();", a)
            time.sleep(random.uniform(0.7, 1.1))
            return True
        except Exception:
            return False

    return False


def _scroll_down(driver: webdriver.Chrome, rounds: int = 10):
    for _ in range(rounds):
        driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
        time.sleep(random.uniform(0.5, 0.9))


def crawl_exchange_symbols(exchange: str, target_n: int, headless: bool = True) -> List[str]:
    """
    Cào mã của 1 sàn đến target_n (hoặc hết dữ liệu).
    """
    url = EXCHANGE_URL[exchange]
    driver = make_driver(headless=headless)
    seen: Set[str] = set()
    symbols: List[str] = []

    try:
        driver.get(url)

        # chờ bảng render
        WebDriverWait(driver, 30).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, "table tbody tr"))
        )
        time.sleep(1.0)

        def collect_once():
            nonlocal symbols
            for sym in _parse_symbols_from_html(driver.page_source):
                if sym not in seen:
                    seen.add(sym)
                    symbols.append(sym)

        collect_once()

        # Nếu ít quá, thử scroll để lộ thêm (trường hợp lazy load)
        if len(symbols) < min(20, target_n):
            _scroll_down(driver, rounds=15)
            collect_once()

        # Nếu có phân trang: bấm Next cho tới đủ
        for _ in range(500):
            if len(symbols) >= target_n:
                break
            clicked = _try_click_next(driver)
            if not clicked:
                break
            collect_once()

        # Nếu không đủ mà không có pagination -> scroll thêm vài vòng
        if len(symbols) < target_n:
            _scroll_down(driver, rounds=20)
            collect_once()

    finally:
        driver.quit()

    return symbols[:target_n]


def crawl_200_symbols(headless: bool = True, out_xlsx: str = "vietstock_200_symbols.xlsx"):
    target_total = 200
    exchanges = ["HOSE", "HNX", "UPCOM"]

    # chia đều ~67 mỗi sàn, nhưng sàn cuối lấy phần còn thiếu
    quota = math.ceil(target_total / len(exchanges))  # 67
    picked: List[Dict[str, str]] = []
    used_pairs: Set[Tuple[str, str]] = set()

    for i, ex in enumerate(exchanges):
        remaining = target_total - len(picked)
        if remaining <= 0:
            break

        target_ex = min(quota, remaining) if i < len(exchanges) - 1 else remaining

        syms = crawl_exchange_symbols(ex, target_n=target_ex, headless=headless)
        print(f"[{ex}] got {len(syms)} symbols (target {target_ex})")

        for s in syms:
            key = (ex, s)
            if key in used_pairs:
                continue
            used_pairs.add(key)
            picked.append({"exchange": ex, "symbol": s})

            if len(picked) >= target_total:
                break

        time.sleep(random.uniform(0.6, 1.2))

    df = pd.DataFrame(picked)
    df["crawled_at"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Xuất Excel
    with pd.ExcelWriter(out_xlsx, engine="openpyxl") as writer:
        df.to_excel(writer, index=False, sheet_name="symbols")

    print(f"Saved: {out_xlsx} | total rows = {len(df)}")


if __name__ == "__main__":
    # headless=False nếu Nhím muốn nhìn trình duyệt chạy
    crawl_200_symbols(headless=True, out_xlsx="vietstock_200_symbols.xlsx")
